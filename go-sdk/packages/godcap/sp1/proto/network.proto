syntax = "proto3";
option go_package="./sp1_proto";

package network;

service ProverNetwork {
  rpc GetNonce(GetNonceRequest) returns (GetNonceResponse);
  rpc RequestProof(RequestProofRequest) returns (RequestProofResponse);
  rpc GetProofRequestStatus(GetProofRequestStatusRequest) returns (GetProofRequestStatusResponse);
  rpc GetProofRequestParams(GetProofRequestParamsRequest) returns (GetProofRequestParamsResponse);
  rpc GetProversByUptime(GetProversByUptimeRequest) returns (GetProversByUptimeResponse);
}

message GetNonceRequest {
    bytes address = 1;
}

message GetNonceResponse {
    uint64 nonce = 1;
}

message RequestProofRequestBody {
    /// The account nonce of the sender.
    uint64 nonce = 1;
    /// The verification key hash of the program.
    bytes vk_hash = 2;
    /// The version of the prover to use.
    string version = 3;
    /// The mode for the request.
    ProofMode mode = 4;
    /// The strategy for fulfiller assignment.
    FulfillmentStrategy strategy = 5;
    /// The stdin resource identifier.
    string stdin_uri = 6;
    /// The deadline for the request.
    uint64 deadline = 7;
    /// The cycle limit for the request.
    uint64 cycle_limit = 8;
    /// The gas limit for the request. If 0, the cycle_limit is used.
    uint64 gas_limit = 9;
    /// The minimum period a request can be in auction in seconds. Zero indicates no minimum.
    uint64 min_auction_period = 10;
    /// The whitelist of provers that can bid and prove this request. An empty list indicates that
    /// any prover can participate.
    repeated bytes whitelist = 11;
    /// The domain separator bytes for the request.
    bytes domain = 12;
    /// The auctioneer address.
    bytes auctioneer = 13;
    /// The executor address.
    bytes executor = 14;
    /// The verifier address.
    bytes verifier = 15;
    /// The optional public values hash.
    optional bytes public_values_hash = 16;
    /// The base fee for the request (string with 18 decimals).
    string base_fee = 17;
    /// The max price per prover gas unit for the request (string with 18 decimals).
    string max_price_per_pgu = 18;
    /// The variant of the transaction.
    TransactionVariant variant = 19;
    /// The treasury address.
    bytes treasury = 20;
}

message RequestProofRequest {
    /// The message format of the body.
    MessageFormat format = 1;
    /// The signature of the sender.
    bytes signature = 2;
    /// The body of the request.
    optional RequestProofRequestBody body = 3;
}

enum ProofMode {
    UnspecifiedProofMode = 0;
    /// The core proof mode.
    Core = 1;
    /// The compressed proof mode.
    Compressed = 2;
    /// The plonk proof mode.
    Plonk = 3;
    /// The groth16 proof mode.
    Groth16 = 4;
}

enum FulfillmentStrategy {
    UnspecifiedFulfillmentStrategy = 0;
    /// The hosted fulfillment strategy. Uses Succinct's on-demand prover to fulfill requests.
    Hosted = 1;
    /// The reserved fulfillment strategy. Uses an already existing agreement with a
    /// fulfiller to fulfill requests.
    Reserved = 2;
    /// The auction fulfillment strategy. Uses a decentralized proof contest to
    /// fulfill requests.
    Auction = 3;
}

enum MessageFormat {
    /// Unspecified message format.
    UnspecifiedMessageFormat = 0;
    /// The message is in binary format.
    Binary = 1;
    /// The message is in JSON format.
    Json = 2;
}

enum TransactionVariant {
    RequestVariant = 0;
    BidVariant = 1;
    SettleVariant = 2;
    ExecuteVariant = 3;
    FulfillVariant = 4;
    DelegateVariant = 5;
    TransferVariant = 6;
    WithdrawVariant = 7;
}

message RequestProofResponse {
    bytes tx_hash = 1;
    optional RequestProofResponseBody body = 2;
}

message RequestProofResponseBody {
    bytes request_id = 1;
}

message GetProofRequestStatusRequest {
  bytes request_id = 1;
}

message GetProofRequestStatusResponse {
  /// The fulfillment status of the request.
  FulfillmentStatus fulfillment_status = 1;
  /// The execution status of the request.
  ExecutionStatus execution_status = 2;
  /// The transaction hash of the request.
  bytes request_tx_hash = 3;
  /// The deadline of the request. A request should be ignored if it is past
  /// its deadline.
  uint64 deadline = 4;
  /// The optional transaction hash of the proof fulfill. Only included if the
  /// request has a fulfillment status of FULFILLED.
  optional bytes fulfill_tx_hash = 5;
  /// The optional proof URI, where you can download the result of the request.
  /// Only included if the request has a fulfillment status of FULFILLED.
  optional string proof_uri = 6;
  /// The optional public values hash from the execution of the request. Only
  /// included if the request has an execution status of EXECUTED.
  optional bytes public_values_hash = 7;
}

enum FulfillmentStatus {
  UnspecifiedFulfillmentStatus = 0;
  /// The request has been requested.
  Requested = 1;
  /// The request has been assigned to a fulfiller.
  Assigned = 2;
  /// The request has been fulfilled.
  Fulfilled = 3;
  /// The request cannot be fulfilled.
  Unfulfillable = 4;
}

enum ExecutionStatus {
  UnspecifiedExecutionStatus = 0;
  /// The request has not been executed.
  Unexecuted = 1;
  /// The request has been executed.
  Executed = 2;
  /// The request cannot be executed.
  Unexecutable = 3;
}

message GetProofRequestParamsRequest {
    /// The mode for the request.
    ProofMode mode = 1;
}

message GetProofRequestParamsResponse {
    /// The domain separator bytes.
    bytes domain = 1;
    /// The default auctioneer address.
    bytes auctioneer = 2;
    /// The default executor address.
    bytes executor = 3;
    /// The default verifier address.
    bytes verifier = 4;
    /// The default max price per prover gas unit (string with 18 decimals).
    string max_price_per_pgu = 5;
    /// The base fee for the specified proof mode (string with 18 decimals).
    string base_fee = 6;
    /// The default treasury address.
    bytes treasury = 7;
}

message GetProversByUptimeRequest {
    /// Whether to only return high availability provers.
    bool high_availability_only = 1;
}

message GetProversByUptimeResponse {
    /// The provers that have historically had reliable uptime.
    repeated bytes provers = 1;
}

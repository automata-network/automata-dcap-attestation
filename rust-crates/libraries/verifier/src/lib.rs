//! High-level verifier for DCAP attestation
//!
//! This crate provides two main verification methods:
//! 1. On-chain verification using smart contracts
//! 2. ZK proof verification using various zkVM coprocessors

pub mod utils;

use alloy::primitives::Bytes;
use alloy::providers::Provider;
use anyhow::{anyhow, Result};
use automata_dcap_evm_bindings::i_automata_dcap_attestation::IAutomataDcapAttestation;
use automata_dcap_network_registry::{ContractKind, Network};
use automata_dcap_utils::Version;

/// ZK coprocessor types supported for proof verification.
///
/// These values map to the zkCoprocessor enum in the AutomataDcapAttestation contract.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum ZkCoprocessor {
    /// No ZK coprocessor (direct on-chain verification).
    None,
    /// RISC Zero zkVM backend.
    Risc0,
    /// Succinct SP1 zkVM backend.
    Sp1,
    /// Pico zkVM backend.
    Pico,
}

impl From<ZkCoprocessor> for u8 {
    fn from(coprocessor: ZkCoprocessor) -> Self {
        match coprocessor {
            ZkCoprocessor::None => 0,
            ZkCoprocessor::Risc0 => 1,
            ZkCoprocessor::Sp1 => 2,
            ZkCoprocessor::Pico => 3,
        }
    }
}

impl TryFrom<u8> for ZkCoprocessor {
    type Error = anyhow::Error;

    fn try_from(value: u8) -> Result<Self> {
        match value {
            0 => Ok(ZkCoprocessor::None),
            1 => Ok(ZkCoprocessor::Risc0),
            2 => Ok(ZkCoprocessor::Sp1),
            3 => Ok(ZkCoprocessor::Pico),
            _ => Err(anyhow!("Invalid ZK coprocessor type: {}", value)),
        }
    }
}

/// Verify a quote directly on-chain using the AutomataDcapAttestation contract.
///
/// This function calls the smart contract to verify the quote and returns the raw verified output bytes.
/// Callers should use `automata_dcap_utils::parser::parse_output_versioned()` to parse the bytes into
/// a structured format.
///
/// # Arguments
/// * `provider` - The Alloy provider to use for blockchain interaction
/// * `deployment_version` - Optional deployment version (v1.0 or v1.1). If None, uses v1.1
/// * `quote_bytes` - The raw quote bytes to verify
/// * `tcb_eval_data_num` - Optional TCB evaluation data number. If None, uses the network's standard value
///
/// # Returns
/// * `Result<Bytes>` - The raw verified output bytes from the contract
///
/// # Example
/// ```no_run
/// use automata_dcap_verifier::verify_and_attest_on_chain;
/// use automata_dcap_utils::{Version, parser};
/// use alloy::providers::ProviderBuilder;
///
/// # async fn example() -> anyhow::Result<()> {
/// let provider = ProviderBuilder::new().on_builtin("http://localhost:8545").await?;
/// let quote_bytes = vec![/* raw quote bytes */];
/// let output_bytes = verify_and_attest_on_chain(
///     &provider,
///     Some(Version::V1_1),
///     &quote_bytes,
///     None
/// ).await?;
///
/// // Parse the output bytes
/// let verified_output = parser::parse_output_versioned(&output_bytes, Version::V1_1)?;
/// println!("Verified output: {:?}", verified_output);
/// # Ok(())
/// # }
/// ```
pub async fn verify_and_attest_on_chain<P: Provider>(
    provider: &P,
    deployment_version: Option<Version>,
    quote_bytes: &[u8],
    tcb_eval_data_num: Option<u32>,
) -> Result<Bytes> {
    // Step 1: Determine the network from the provider
    let network = Network::from_provider(provider, deployment_version).await?;

    // Step 2: Resolve the DcapAttestation contract address
    let contract_address = network
        .resolve_contract_address(ContractKind::DcapAttestation, None, None)
        .await?;

    // Step 3: Create contract instance
    let contract = IAutomataDcapAttestation::new(contract_address, provider);

    // Step 4: Call the appropriate verifyAndAttestOnChain function
    let (success, output) = if let Some(tcb_eval_num) = tcb_eval_data_num {
        // _0 variant takes (rawQuote, tcbEvaluationDataNumber)
        let call =
            contract.verifyAndAttestOnChain_0(Bytes::from(quote_bytes.to_vec()), tcb_eval_num);
        let result = call.call().await?;
        (result.success, result.output)
    } else {
        // _1 variant takes (rawQuote) only
        let call = contract.verifyAndAttestOnChain_1(Bytes::from(quote_bytes.to_vec()));
        let result = call.call().await?;
        (result.success, result.output)
    };

    // Step 5: Check success
    if !success {
        let error_message = String::from_utf8_lossy(&output);
        return Err(anyhow!(
            "Quote Onchain Verification Error: {}",
            error_message
        ));
    }

    // Step 6: Return raw output bytes (caller should parse using automata_dcap_utils::parser)
    Ok(output)
}

/// Verify a quote using a ZK proof generated by a zkVM coprocessor.
///
/// This function calls the smart contract to verify that the proof is valid and returns the raw
/// verified output bytes. Callers should use `automata_dcap_utils::parser::parse_output_versioned()`
/// to parse the bytes into a structured format.
///
/// # Arguments
/// * `provider` - The Alloy provider to use for blockchain interaction
/// * `deployment_version` - Optional deployment version (v1.0 or v1.1). If None, uses v1.1
/// * `output_bytes` - The output bytes from the zkVM (the journal/public values)
/// * `zk_coprocessor` - The zkVM type (RISC0, SP1, or Pico)
/// * `proof_bytes` - The proof bytes from the zkVM
/// * `program_identifier` - Optional program identifier (e.g., image ID for RISC0, VK hash for SP1)
/// * `tcb_eval_data_num` - Optional TCB evaluation data number
///
/// # Returns
/// * `Result<Bytes>` - The raw verified output bytes from the contract
///
/// # Example
/// ```no_run
/// use automata_dcap_verifier::{verify_and_attest_with_zk_proof, ZkCoprocessor};
/// use automata_dcap_utils::{Version, parser};
/// use alloy::providers::ProviderBuilder;
/// use alloy::primitives::FixedBytes;
///
/// # async fn example() -> anyhow::Result<()> {
/// let provider = ProviderBuilder::new().on_builtin("http://localhost:8545").await?;
/// let journal_bytes = vec![/* zkVM journal/output bytes */];
/// let proof_bytes = vec![/* proof bytes */];
/// let program_id = FixedBytes::from([0u8; 32]);
/// let verified_output_bytes = verify_and_attest_with_zk_proof(
///     &provider,
///     Some(Version::V1_1),
///     &journal_bytes,
///     ZkCoprocessor::Risc0,
///     &proof_bytes,
///     Some(program_id),
///     None,
/// ).await?;
///
/// // Parse the output bytes
/// let verified_output = parser::parse_output_versioned(&verified_output_bytes, Version::V1_1)?;
/// println!("Verified output: {:?}", verified_output);
/// # Ok(())
/// # }
/// ```
pub async fn verify_and_attest_with_zk_proof<P: Provider>(
    provider: &P,
    deployment_version: Option<Version>,
    output_bytes: &[u8],
    zk_coprocessor: ZkCoprocessor,
    proof_bytes: &[u8],
    program_identifier: Option<alloy::primitives::FixedBytes<32>>,
    tcb_eval_data_num: Option<u32>,
) -> Result<Bytes> {
    // Step 1: Determine the network from the provider
    let network = Network::from_provider(provider, deployment_version).await?;

    // Step 2: Resolve the DcapAttestation contract address
    let contract_address = network
        .resolve_contract_address(ContractKind::DcapAttestation, None, None)
        .await?;

    // Step 3: Create contract instance
    let contract = IAutomataDcapAttestation::new(contract_address, provider);

    // Convert enum to u8 for contract call
    let zk_coprocessor_u8: u8 = zk_coprocessor.into();

    // Step 4: Call the appropriate verifyAndAttestWithZKProof function
    let deployment_version = deployment_version.unwrap_or(Version::V1_1);
    let (success, verified_output_bytes) =
        if deployment_version == Version::V1_0 || tcb_eval_data_num.is_none() {
            // _0 variant takes (output, zkCoprocessor, proofBytes)
            let call = contract.verifyAndAttestWithZKProof_0(
                Bytes::from(output_bytes.to_vec()),
                zk_coprocessor_u8,
                Bytes::from(proof_bytes.to_vec()),
            );
            let result = call.call().await?;
            (result.success, result.verifiedOutput)
        } else {
            // TEMP: if user does not provide program_identifier fetch latest program identifier from contract
            let program_id = if let Some(pid) = program_identifier {
                pid
            } else {
                let latest_program_id_call = contract.programIdentifier(zk_coprocessor_u8);
                let latest_program_id = latest_program_id_call.call().await?;
                latest_program_id
            };

            // _1 variant takes (output, zkCoprocessor, proofBytes, programIdentifier, tcbEvaluationDataNumber)
            // Use default values for missing parameters
            let tcb_eval_num = tcb_eval_data_num.unwrap_or(0);

            let call = contract.verifyAndAttestWithZKProof_1(
                Bytes::from(output_bytes.to_vec()),
                zk_coprocessor_u8,
                Bytes::from(proof_bytes.to_vec()),
                program_id,
                tcb_eval_num,
            );
            let result = call.call().await?;
            (result.success, result.verifiedOutput)
        };

    // Step 5: Check success
    if !success {
        let error_message = String::from_utf8_lossy(&verified_output_bytes);
        return Err(anyhow!(
            "Quote Onchain Verification Error: {}",
            error_message
        ));
    }

    // Step 6: Return raw output bytes (caller should parse using automata_dcap_utils::parser)
    Ok(verified_output_bytes)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::read_proof_artifact;
    use automata_dcap_network_registry::Network;

    #[tokio::test]
    async fn test_onchain_verification() {
        let default_provider =
            Network::create_provider(Network::default_network(None).unwrap(), None, None).unwrap();

        let cargo_manifest_dir = env!("CARGO_MANIFEST_DIR");
        let quote_path = format!("{}/../../samples/quotev4.hex", cargo_manifest_dir);
        let quote_hex = std::fs::read_to_string(quote_path.as_str()).unwrap();
        let quote_bytes = hex::decode(quote_hex.trim()).unwrap();

        let verified =
            verify_and_attest_on_chain(&default_provider, None, quote_bytes.as_slice(), None).await;

        assert!(verified.is_ok());
    }

    #[tokio::test]
    async fn test_zk_verification() {
        let cargo_manifest_dir = env!("CARGO_MANIFEST_DIR");
        let json_path = format!("{}/../../output/boundless.json", cargo_manifest_dir);

        // Skip test if file doesn't exist
        if !std::path::Path::new(&json_path).exists() {
            eprintln!("Skipping test: boundless.json not found at {}", json_path);
            return;
        }

        let parsed = read_proof_artifact(&json_path).unwrap();

        let default_provider =
            Network::create_provider(Network::default_network(None).unwrap(), None, None).unwrap();

        let verified = verify_and_attest_with_zk_proof(
            &default_provider,
            None,
            &parsed.output_bytes,
            parsed.zk_coprocessor,
            &parsed.proof_bytes,
            Some(parsed.program_identifier),
            None,
        )
        .await;

        assert!(verified.is_ok());
    }
}

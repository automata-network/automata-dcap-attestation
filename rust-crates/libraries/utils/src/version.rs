use serde::{Deserialize, Serialize};
use std::fmt;
use std::str::FromStr;
#[doc = r" Version enum representing supported DCAP deployment versions"]
#[doc = r""]
#[doc = r" This module is auto-generated from version.toml at build time."]
#[doc = r" Do not edit this file manually."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Version {
    #[serde(rename = "v1.0")]
    V1_0,
    #[serde(rename = "v1.1")]
    V1_1,
}
impl Version {
    #[doc = r" Get all supported versions"]
    pub fn all() -> Vec<Version> {
        vec![Version::V1_0, Version::V1_1]
    }
    #[doc = r#" Get the version string (e.g., "v1.0")"#]
    pub fn as_str(&self) -> &'static str {
        match self {
            Version::V1_0 => "v1.0",
            Version::V1_1 => "v1.1",
        }
    }
    #[doc = r" Check if this version supports TcbEvalDao"]
    pub fn supports_tcb_eval_dao(&self) -> bool {
        match self {
            Version::V1_0 => false,
            Version::V1_1 => true,
        }
    }
    #[doc = r" Check if this version uses versioned DAOs"]
    pub fn uses_versioned_daos(&self) -> bool {
        match self {
            Version::V1_0 => false,
            Version::V1_1 => true,
        }
    }
}
impl fmt::Display for Version {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
impl FromStr for Version {
    type Err = anyhow::Error;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "v1.0" | "v1_0" | "1.0" => Ok(Version::V1_0),
            "v1.1" | "v1_1" | "1.1" => Ok(Version::V1_1),
            "current" => Ok(Version::V1_1),
            _ => Err(anyhow::anyhow!("Unsupported version: {}", s)),
        }
    }
}
#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn test_version_from_str() {
        assert_eq!(Version::from_str("v1.0").unwrap(), Version::V1_0);
        assert_eq!(Version::from_str("v1_0").unwrap(), Version::V1_0);
        assert_eq!(Version::from_str("1.0").unwrap(), Version::V1_0);
        assert_eq!(Version::from_str("v1.1").unwrap(), Version::V1_1);
        assert_eq!(Version::from_str("v1_1").unwrap(), Version::V1_1);
        assert_eq!(Version::from_str("1.1").unwrap(), Version::V1_1);
        assert!(Version::from_str("v99.99").is_err());
    }
    #[test]
    fn test_version_tcb_eval_dao() {
        assert!(!Version::V1_0.supports_tcb_eval_dao());
        assert!(Version::V1_1.supports_tcb_eval_dao());
    }
    #[test]
    fn test_version_uses_versioned_daos() {
        assert!(!Version::V1_0.uses_versioned_daos());
        assert!(Version::V1_1.uses_versioned_daos());
    }
}

use anyhow::{anyhow, bail};
use sha2::{Digest, Sha256};
use zerocopy::little_endian;

use crate::{
    types::{quote::QuoteCertData, report::EnclaveReportBody, sgx_x509::SgxPckExtension},
    utils,
};

use super::{CertificationKeyType, PckCertChainData};

/// Signature data for SGX Quotes
///
/// In the intel docs, this is A 4.4: "ECDSA 2560bit Quote Signature Data Structure"
///
/// This can be used to validate that the quoting enclave itself is valid, and then that
/// the quoting enclave has signed the ISV enclave report.
#[derive(Debug)]
pub struct QuoteSignatureData<'a> {
    /// Signature of the report header + report by the attestation key.
    pub isv_signature: &'a [u8],

    /// The public key used to generate the isv_signature.
    pub attestation_pub_key: &'a [u8],

    /// Report of the quoting enclave.
    pub qe_report_body: EnclaveReportBody,

    /// Signature of the quoting enclave report using the PCK cert key.
    pub qe_report_signature: &'a [u8],

    /// Auth data for the quote
    pub auth_data: &'a [u8],

    /// Cert data
    pub cert_data: QuoteCertData<'a>,
}

impl<'a> QuoteSignatureData<'a> {
    pub fn read(bytes: &mut &'a [u8], version: u16) -> anyhow::Result<Self> {
        let signature_len = utils::read_from_bytes::<little_endian::U32>(bytes)
            .ok_or_else(|| anyhow!("underflow reading signature length"))?
            .get();

        if bytes.len() < signature_len as usize {
            return Err(anyhow!("underflow reading signature"));
        }

        if version == 3 {
            Self::read_v3_signature(bytes)
        } else if version >= 4 {
            Self::read_v4_signature(bytes)
        } else {
            Err(anyhow!("unsupported quote version"))
        }
    }

    fn read_v3_signature(bytes: &mut &'a [u8]) -> anyhow::Result<Self> {
        let isv_signature = utils::read_bytes(bytes, 64);

        let attestation_pub_key = utils::read_bytes(bytes, 64);

        let qe_report_body = utils::read_from_bytes::<EnclaveReportBody>(bytes)
            .ok_or_else(|| anyhow!("underflow reading enclave report body"))?;

        let qe_report_signature = utils::read_bytes(bytes, 64);

        let auth_data_size = utils::read_from_bytes::<little_endian::U16>(bytes)
            .ok_or_else(|| anyhow!("Failed to read auth data size"))?
            .get();

        if bytes.len() < auth_data_size as usize {
            return Err(anyhow!("buffer underflow"));
        }

        let auth_data = utils::read_bytes(bytes, auth_data_size as usize);
        let cert_data = QuoteCertData::read(bytes)?;

        Ok(QuoteSignatureData {
            isv_signature,
            attestation_pub_key,
            qe_report_body,
            qe_report_signature,
            auth_data,
            cert_data,
        })
    }

    fn read_v4_signature(bytes: &mut &'a [u8]) -> anyhow::Result<Self> {
        let isv_signature = utils::read_bytes(bytes, 64);

        let attestation_pub_key = utils::read_bytes(bytes, 64);

        let mut cert_data_struct = QuoteCertData::read(bytes)?;

        if cert_data_struct.cert_key_type.get() != CertificationKeyType::EcdsaSigAuxData as u16 {
            return Err(anyhow!(
                "cannot transform cert data into quoting enclave report cert data"
            ));
        }

        // Parse the QE report
        let qe_report_body =
            utils::read_from_bytes::<EnclaveReportBody>(&mut cert_data_struct.cert_data)
                .ok_or_else(|| anyhow!("underflow reading enclave report body"))?;

        // Parse the QE report signature
        let qe_report_signature = utils::read_bytes(&mut cert_data_struct.cert_data, 64);

        // Read auth data size and auth data
        let auth_data_size =
            utils::read_from_bytes::<little_endian::U16>(&mut cert_data_struct.cert_data)
                .ok_or_else(|| anyhow!("Failed to read auth data size"))?;

        if cert_data_struct.cert_data.len() < auth_data_size.get() as usize {
            return Err(anyhow!("buffer underflow"));
        }

        let qe_auth_data = utils::read_bytes(
            &mut cert_data_struct.cert_data,
            auth_data_size.get() as usize,
        );
        let cert_data = QuoteCertData::read(&mut cert_data_struct.cert_data)?;

        Ok(QuoteSignatureData {
            isv_signature,
            attestation_pub_key,
            qe_report_body,
            qe_report_signature,
            auth_data: qe_auth_data,
            cert_data,
        })
    }

    pub fn get_pck_cert_chain(&self) -> anyhow::Result<PckCertChainData> {
        self.cert_data.as_pck_cert_chain_data()
    }

    pub fn get_pck_extension(&self) -> anyhow::Result<SgxPckExtension> {
        self.cert_data.get_pck_extension()
    }

    /// Verify the report generated by the quoting enclave.
    ///
    /// By specification, the quoting enclave report data `sgx_report_data_bytes` must be
    /// SHA256(ECDSA Attestation Key || QE Authentication Data) || 32 Ã— 0x00 bytes
    pub fn verify_qe_report(&self) -> anyhow::Result<()> {
        let mut hasher = Sha256::new();

        hasher.update(self.attestation_pub_key);
        hasher.update(self.auth_data);
        let digest = hasher.finalize();
        assert_eq!(digest.len(), 32);

        if *digest != self.qe_report_body.user_report_data[..digest.len()] {
            bail!("Quoting enclave report should be hash of attestation key and auth data");
        }

        if self.qe_report_body.user_report_data[digest.len()..] != [0; 32] {
            bail!("Quoting enclave report should be 32 zero bytes padded");
        }

        Ok(())
    }

    /// Calculate the total byte length of the signature data structure
    ///
    /// This returns the exact number of bytes that this signature data occupies,
    /// including all fields and the signature length prefix.
    pub fn byte_len(&self, version: u16) -> usize {
        // Signature length field (4 bytes)
        let mut total = 4;

        // ISV signature (64 bytes)
        total += 64;

        // Attestation public key (64 bytes)
        total += 64;

        if version == 3 {
            // V3 format:
            // QE report body
            total += std::mem::size_of::<EnclaveReportBody>();

            // QE report signature (64 bytes)
            total += 64;

            // Auth data size (2 bytes)
            total += 2;

            // Auth data
            total += self.auth_data.len();

            // Cert data (type: 2 bytes, size: 4 bytes, data: cert_data_size bytes)
            total += 2 + 4 + self.cert_data.cert_data.len();
        } else {
            // V4+ format:
            // Cert data header (type: 2 bytes, size: 4 bytes)
            total += 2 + 4;

            // Cert data contains: QE report + QE signature + auth data size + auth data + nested cert data
            // QE report body
            total += std::mem::size_of::<EnclaveReportBody>();

            // QE report signature (64 bytes)
            total += 64;

            // Auth data size (2 bytes)
            total += 2;

            // Auth data
            total += self.auth_data.len();

            // Nested cert data (type: 2 bytes, size: 4 bytes, data: cert_data_size bytes)
            total += 2 + 4 + self.cert_data.cert_data.len();
        }

        total
    }
}

impl<'a> std::fmt::Display for QuoteSignatureData<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "  Signature Data:")?;
        writeln!(
            f,
            "    ISV Signature: {}",
            hex::encode(&self.isv_signature[..32])
        )?;
        writeln!(
            f,
            "    Attestation Public Key: {}",
            hex::encode(&self.attestation_pub_key[..32])
        )?;

        writeln!(f, "    Quoting Enclave Report:")?;
        writeln!(
            f,
            "      MR_ENCLAVE: {}",
            hex::encode(self.qe_report_body.mr_enclave)
        )?;
        writeln!(
            f,
            "      MR_SIGNER: {}",
            hex::encode(self.qe_report_body.mr_signer)
        )?;
        writeln!(f, "      ISV_PROD_ID: {}", self.qe_report_body.isv_prod_id)?;
        writeln!(f, "      ISV_SVN: {}", self.qe_report_body.isv_svn)?;

        writeln!(
            f,
            "    QE Report Signature: {}",
            hex::encode(&self.qe_report_signature[..32])
        )?;
        writeln!(f, "    Auth Data Size: {} bytes", self.auth_data.len())?;

        writeln!(
            f,
            "    Cert Key Type: {} ({})",
            self.cert_data.cert_key_type.get(),
            match self.cert_data.cert_key_type.get() {
                1 => "[PPID, CPUSVN, PCESVN (LE), PCEID (LE)]",
                2 => "[Encrypted PPID with RSA-2048-OAEP, CPUSVN, PCESVN (LE), PCEID (LE)]",
                3 => "[Encrypted PPID with RSA-3072-OAEP, CPUSVN, PCESVN (LE), PCEID (LE)]",
                4 => "PCK Leaf Certificate",
                5 => "PCK Cert Chain",
                6 => "ECDSA Sig Aux Data",
                _ => "Unknown",
            }
        )?;
        writeln!(
            f,
            "    Cert Data Size: {} bytes",
            self.cert_data.cert_data_size.get()
        )?;

        // Parse and display certificates for PCK Leaf Cert (4) or PCK Cert Chain (5)
        match self.cert_data.cert_key_type.get() {
            4 | 5 => {
                // Try to parse as PCK cert chain
                match self.cert_data.as_pck_cert_chain_data() {
                    Ok(pck_data) => {
                        writeln!(f, "    Certificate Chain ({} certificates):", pck_data.pck_cert_chain.len())?;
                        for (i, cert) in pck_data.pck_cert_chain.iter().enumerate() {
                            writeln!(f, "      [{}] Subject: {}", i, cert.tbs_certificate.subject)?;
                            writeln!(f, "          Issuer:  {}", cert.tbs_certificate.issuer)?;
                            writeln!(
                                f,
                                "          Valid: {} to {}",
                                cert.tbs_certificate.validity.not_before,
                                cert.tbs_certificate.validity.not_after
                            )?;
                        }

                        // Display PCK extension info
                        writeln!(f, "    PCK Extension:")?;
                        writeln!(f, "      FMSPC: {}", hex::encode(&pck_data.pck_extension.fmspc))?;
                        writeln!(f, "      PCE ID: {}", hex::encode(&pck_data.pck_extension.pceid))?;
                        writeln!(f, "      PCE SVN: {}", pck_data.pck_extension.tcb.pcesvn)?;
                        writeln!(f, "      CPU SVN: {}", hex::encode(&pck_data.pck_extension.tcb.cpusvn))?;
                    }
                    Err(e) => {
                        writeln!(f, "    (Failed to parse certificate chain: {})", e)?;
                        writeln!(f, "    Raw Cert Data: {}", hex::encode(self.cert_data.cert_data))?;
                    }
                }
            }
            _ => {
                // For other types, just display raw hex
                writeln!(f, "    Cert Data (hex): {}", hex::encode(self.cert_data.cert_data))?;
            }
        }

        Ok(())
    }
}

#[derive(Debug, zerocopy::FromBytes, zerocopy::FromZeroes)]
pub struct EcdsaSignatureHeader {
    pub isv_signature: [u8; 64],
    pub attestation_pub_key: [u8; 64],
}
